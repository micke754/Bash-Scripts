#!/usr/bin/env bash

# --- Script Configuration ---
APP_NAME="pwshFmt"
if [[ -n "$XDG_CONFIG_HOME" ]]; then
    CONFIG_DIR="$XDG_CONFIG_HOME/powershell"
else
    CONFIG_DIR="$HOME/.config/powershell"
fi
PREFERRED_SETTINGS_FILE_PATH="$CONFIG_DIR/PSScriptFormatterSettings.psd1"
# --- End Script Configuration ---

# --- Global Variables for Options ---
flag_verbose=false
flag_silent=false
flag_stdin_mode=false
target_ps_script_path_arg=""
ABS_PS_SCRIPT_PATH=""
ACTUAL_SETTINGS_ARG_FOR_PWSH=""
# --- End Global Variables ---

# --- Helper Functions ---
# ... (show_help, _log_error, _log_error_and_exit, _log_verbose, _log_normal - UNCHANGED) ...
show_help() {
    cat << EOF
Usage: $APP_NAME [options] [path_to_script.ps1]

Formats a PowerShell script using Invoke-Formatter.
If <path_to_script.ps1> is provided, formats the file in-place.
If --stdin is used, reads from stdin and writes formatted output to stdout.

Formatting rules are sourced from:
  $PREFERRED_SETTINGS_FILE_PATH
If this file is not found, Invoke-Formatter's internal default rules will be used.

Options:
  --stdin           Read script from stdin, write formatted script to stdout.
  -v, --verbose     Enable verbose output (ignored in --stdin mode unless errors).
  -s, --silent      Enable silent output (only errors, default for --stdin mode).
  -h, --help        Display this help message and exit.
EOF
}

_log_error() {
    echo "$APP_NAME: Error: $@" >&2
}

_log_error_and_exit() {
    _log_error "$1"
    if [[ "${2:-}" == "show_help" ]]; then
        echo "" >&2
        show_help >&2
    fi
    exit "${3:-1}"
}

_log_verbose() {
    if [[ "$flag_stdin_mode" == false && "$flag_verbose" == true ]]; then
        echo "$@"
    fi
}

_log_normal() {
    if [[ "$flag_stdin_mode" == false && "$flag_silent" == false ]]; then
        echo "$@"
    fi
}
# --- End Helper Functions ---

# --- Argument Parsing ---
# ... (Argument parsing logic - UNCHANGED) ...
parsed_args=()
while [[ "$#" -gt 0 ]]; do
    case "$1" in
        --stdin)
            flag_stdin_mode=true
            flag_silent=true
            shift
            ;;
        -v|--verbose)
            flag_verbose=true
            shift
            ;;
        -s|--silent)
            flag_silent=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -*)
            _log_error_and_exit "Unknown option: $1" "show_help"
            ;;
        *)
            if [[ "$flag_stdin_mode" == false && -n "$target_ps_script_path_arg" ]]; then
                _log_error_and_exit "Too many script paths provided. Expected one, or use --stdin." "show_help"
            elif [[ "$flag_stdin_mode" == false ]]; then
                target_ps_script_path_arg="$1"
            fi
            shift
            ;;
    esac
done

if [[ "$flag_silent" == true ]]; then
    flag_verbose=false
fi
# --- End Argument Parsing ---

# --- Pre-execution Checks ---
if ! command -v pwsh &> /dev/null; then
    _log_error_and_exit "'pwsh' (PowerShell) command not found. Please install PowerShell Core."
fi

if [[ -f "$PREFERRED_SETTINGS_FILE_PATH" ]]; then
    ACTUAL_SETTINGS_ARG_FOR_PWSH="$PREFERRED_SETTINGS_FILE_PATH"
    # Logging for this is handled later depending on mode
else
    # ACTUAL_SETTINGS_ARG_FOR_PWSH remains empty.
    if [[ "$flag_stdin_mode" == false ]]; then # Only log normally if not in stdin mode
         _log_normal "Note: Custom settings file not found at '$PREFERRED_SETTINGS_FILE_PATH'. Using Invoke-Formatter defaults."
    fi
    _log_verbose "Custom settings file not found. Invoke-Formatter will use its defaults (verbose log)."
fi
# --- End Pre-execution Checks ---

# ===========================
# STDIN to STDOUT Mode (Helix)
# ===========================
if [[ "$flag_stdin_mode" == true ]]; then
    # ... (stdin setup logic, including reading from cat - UNCHANGED) ...
    if [[ -n "$target_ps_script_path_arg" ]]; then
        : # Warning already logged in verbose
    fi

    script_content_from_stdin=$(cat)
    if [[ -z "$script_content_from_stdin" && ! -t 0 ]]; then
        exit 0
    elif [[ -z "$script_content_from_stdin" && -t 0 ]]; then
        _log_error_and_exit "No script content provided via stdin."
    fi

    CORE_PWSH_LOGIC_STDIN=$(cat <<'EOF'
$ErrorActionPreference = 'Stop'
# $scriptContent, $settingsPathOrNull (can be empty string for defaults) will be passed

if (-not (Get-Module PSScriptAnalyzer -ListAvailable)) {
    try { Install-Module PSScriptAnalyzer -Scope CurrentUser -Force -Confirm:$false -ErrorAction Stop > $null } catch { exit 1 }
}
Import-Module PSScriptAnalyzer -ErrorAction Stop

try {
    if ([string]::IsNullOrEmpty($settingsPathOrNull)) {
        $formattedContent = Invoke-Formatter -ScriptDefinition $scriptContent -ErrorAction Stop
    } else {
        $formattedContent = Invoke-Formatter -ScriptDefinition $scriptContent -Settings $settingsPathOrNull -ErrorAction Stop
    }
    Write-Output $formattedContent
} catch {
    $errorMessage = "pwshFmt (stdin): PowerShell Formatting Error:`n"
    $errorMessage += "Exception Type: $($_.Exception.GetType().FullName)`n"
    $errorMessage += "Exception Message: $($_.Exception.Message)`n"
    if ($_.ScriptStackTrace) { $errorMessage += "ScriptStackTrace:`n$($_.ScriptStackTrace)`n" }
    Write-Error $errorMessage # To STDERR
    exit 1
}
EOF
    )

    settings_arg_val_stdin="${ACTUAL_SETTINGS_ARG_FOR_PWSH:-}"

    export PWSHFMT_SCRIPT_CONTENT="$script_content_from_stdin"
    # Construct parameter string carefully for PowerShell
    # Ensures -settingsPathOrNull "" is passed if settings_arg_val_stdin is empty
    FULL_PWSH_COMMAND_STDIN="\$scriptContent = \$env:PWSHFMT_SCRIPT_CONTENT; & { param([string]\$settingsPathOrNull); $CORE_PWSH_LOGIC_STDIN } -settingsPathOrNull \"$settings_arg_val_stdin\""


    if pwsh -NoProfile -Command "$FULL_PWSH_COMMAND_STDIN"; then
        unset PWSHFMT_SCRIPT_CONTENT
        exit 0
    else
        unset PWSHFMT_SCRIPT_CONTENT
        exit 1
    fi
fi # End of stdin_mode


# ===========================
# File In-Place Mode (Original)
# ===========================
if [[ -z "$target_ps_script_path_arg" ]]; then
     _log_error_and_exit "No PowerShell script path provided and --stdin not used." "show_help"
fi

# ... (ABS_PS_SCRIPT_PATH resolution - UNCHANGED) ...
if command -v realpath &> /dev/null; then
    ABS_PS_SCRIPT_PATH="$(realpath "$target_ps_script_path_arg")"
elif command -v readlink &> /dev/null && readlink -f / &> /dev/null; then
    ABS_PS_SCRIPT_PATH="$(readlink -f "$target_ps_script_path_arg")"
else
    if [[ "${target_ps_script_path_arg:0:1}" == "/" ]] || [[ "${target_ps_script_path_arg:0:2}" == "~/" ]]; then
        if [[ "${target_ps_script_path_arg:0:2}" == "~/" ]]; then
            ABS_PS_SCRIPT_PATH="$HOME/${target_ps_script_path_arg:2}"
        else
            ABS_PS_SCRIPT_PATH="$target_ps_script_path_arg"
        fi
    else
        ABS_PS_SCRIPT_PATH="$PWD/$target_ps_script_path_arg"
    fi
fi

if [[ ! -f "$ABS_PS_SCRIPT_PATH" ]]; then
    _log_error_and_exit "PowerShell script not found at '$ABS_PS_SCRIPT_PATH' (resolved from '$target_ps_script_path_arg')."
fi

_log_verbose "Verbose mode enabled (file mode)."
_log_verbose "Attempting to format: '$ABS_PS_SCRIPT_PATH'"
if [[ -n "$ACTUAL_SETTINGS_ARG_FOR_PWSH" ]]; then
    _log_verbose "Using custom settings from (path): '$ACTUAL_SETTINGS_ARG_FOR_PWSH'"
else
    _log_verbose "Using Invoke-Formatter default settings (custom file not found)."
fi
_log_verbose "---"

initial_timestamp=""
# ... (timestamp logic - UNCHANGED) ...
if [[ "$flag_silent" == false ]]; then
    if command -v stat &> /dev/null; then
        if stat -c %Y "$ABS_PS_SCRIPT_PATH" &> /dev/null; then
            initial_timestamp=$(stat -c %Y "$ABS_PS_SCRIPT_PATH")
        elif stat -f %m "$ABS_PS_SCRIPT_PATH" &> /dev/null; then
            initial_timestamp=$(stat -f %m "$ABS_PS_SCRIPT_PATH")
        fi
        [[ -n "$initial_timestamp" ]] && _log_verbose "Initial file timestamp: $initial_timestamp"
    fi
fi

start_time_ns=$(date +%s%N)

CORE_PWSH_LOGIC_FILE=$(cat <<'EOF'
$ErrorActionPreference = 'Stop'

if ($pwshVerboseFlag) {
    Write-Host "PowerShell side (inside invoked block, verbose mode, file mode):"
    Write-Host "  Script to format: $scriptToFormatPath"
    if ([string]::IsNullOrEmpty($settingsPathOrNull)) {
        Write-Host "  Using Invoke-Formatter default settings."
    } else {
        Write-Host "  Settings file path: $settingsPathOrNull"
    }
}

if (-not (Get-Module PSScriptAnalyzer -ListAvailable)) {
    if ($pwshVerboseFlag) { Write-Warning "PSScriptAnalyzer module not found..." }
    try { Install-Module PSScriptAnalyzer -Scope CurrentUser -Force -Confirm:$false -ErrorAction Stop } catch { Write-Error "Failed to install PSScriptAnalyzer."; exit 1 }
    if ($pwshVerboseFlag) { Write-Host "PSScriptAnalyzer installed." -ForegroundColor Green }
}
Import-Module PSScriptAnalyzer -ErrorAction Stop

try {
    if ($pwshVerboseFlag) { Write-Host "---"; Write-Host "Formatting script with Invoke-Formatter..." }
    $originalContent = Get-Content -Path $scriptToFormatPath -Raw -Encoding UTF8

    if ([string]::IsNullOrEmpty($settingsPathOrNull)) {
        $formattedContent = Invoke-Formatter -ScriptDefinition $originalContent -ErrorAction Stop
    } else {
        $formattedContent = Invoke-Formatter -ScriptDefinition $originalContent -Settings $settingsPathOrNull -ErrorAction Stop
    }

    if ($formattedContent -ne $originalContent) {
        Set-Content -Path $scriptToFormatPath -Value $formattedContent -Encoding UTF8 -Force
        if ($pwshVerboseFlag) { Write-Host "PowerShell: Script '$scriptToFormatPath' has been formatted." -ForegroundColor Green }
    } else {
        if ($pwshVerboseFlag) { Write-Host "PowerShell: Script '$scriptToFormatPath' is already formatted. No changes made." -ForegroundColor Cyan }
    }
} catch {
    $errorMessage = "PowerShell Error Details (file mode):`n"
    $errorMessage += "Exception Type: $($_.Exception.GetType().FullName)`n"
    $errorMessage += "Exception Message: $($_.Exception.Message)`n"
    if ($_.ScriptStackTrace) { $errorMessage += "ScriptStackTrace:`n$($_.ScriptStackTrace)`n" }
    Write-Output $errorMessage
    exit 1
}
EOF
)

# Construct parameter string for file mode carefully
pwsh_param_string_file="-scriptToFormatPath \"$ABS_PS_SCRIPT_PATH\""
# Ensure -settingsPathOrNull "" is passed if ACTUAL_SETTINGS_ARG_FOR_PWSH is empty
pwsh_param_string_file+=" -settingsPathOrNull \"${ACTUAL_SETTINGS_ARG_FOR_PWSH:-}\""
if [[ "$flag_verbose" == true ]]; then
    pwsh_param_string_file+=" -pwshVerboseFlag \$true"
else
    pwsh_param_string_file+=" -pwshVerboseFlag \$false"
fi
FULL_PWSH_COMMAND_FILE="& { param([string]\$scriptToFormatPath, [string]\$settingsPathOrNull, [bool]\$pwshVerboseFlag); $CORE_PWSH_LOGIC_FILE } $pwsh_param_string_file"


pwsh_output_capture_file=$(mktemp)
trap 'rm -f "$pwsh_output_capture_file"' EXIT

execution_succeeded=false
# ... (pwsh execution and post-processing - UNCHANGED) ...
if pwsh -NoProfile -Command "$FULL_PWSH_COMMAND_FILE" > "$pwsh_output_capture_file" 2>&1; then
    execution_succeeded=true
else
    execution_succeeded=false
fi

end_time_ns=$(date +%s%N)
duration_ns=$((end_time_ns - start_time_ns))

final_timestamp=""
file_was_modified=false
if [[ "$flag_silent" == false || "$execution_succeeded" == false ]]; then
    if command -v stat &> /dev/null; then
        if stat -c %Y "$ABS_PS_SCRIPT_PATH" &> /dev/null; then final_timestamp=$(stat -c %Y "$ABS_PS_SCRIPT_PATH"); fi
        if [[ -z "$final_timestamp" ]] && stat -f %m "$ABS_PS_SCRIPT_PATH" &> /dev/null; then final_timestamp=$(stat -f %m "$ABS_PS_SCRIPT_PATH"); fi
    fi
    if [[ -n "$initial_timestamp" && -n "$final_timestamp" && "$initial_timestamp" != "$final_timestamp" ]]; then
        file_was_modified=true
    fi
fi

if [[ "$execution_succeeded" == true ]]; then
    if [[ "$file_was_modified" == true ]]; then
        _log_normal "Formatted: '$ABS_PS_SCRIPT_PATH'"
    else
        _log_normal "No changes: '$ABS_PS_SCRIPT_PATH' (already compliant)"
    fi
    _log_verbose "$(cat "$pwsh_output_capture_file")"
else
    _log_error "Formatting failed for '$ABS_PS_SCRIPT_PATH'."
    cat "$pwsh_output_capture_file" >&2 # Show PS errors
fi

if [[ "$flag_silent" == false || "$execution_succeeded" == false ]]; then
    duration_s=$(awk -v ns="$duration_ns" 'BEGIN{printf "%.3f", ns/1000000000}')
    if [[ "$flag_silent" == false ]]; then
        _log_normal "Execution time: ${duration_s}s"
    elif [[ "$execution_succeeded" == false && "$flag_silent" == true ]]; then
        echo "Execution time: ${duration_s}s" >&2
    fi
    _log_verbose "Detailed execution time: ${duration_ns}ns ($(awk -v ns="$duration_ns" 'BEGIN{printf "%d", ns/1000000}')ms)"
fi

if [[ "$execution_succeeded" == true ]]; then
    exit 0
else
    exit 1
fi
