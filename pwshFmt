#!/usr/bin/env bash

# --- Script Configuration ---
APP_NAME="pwshFmt"
if [[ -n "$XDG_CONFIG_HOME" ]]; then
    CONFIG_DIR="$XDG_CONFIG_HOME/powershell"
else
    CONFIG_DIR="$HOME/.config/powershell"
fi
SETTINGS_FILE_PATH="$CONFIG_DIR/PSScriptFormatterSettings.psd1"
# --- End Script Configuration ---

# --- Global Variables for Options ---
flag_verbose=false
flag_silent=false
flag_stdin_mode=false
target_ps_script_path_arg="" # Will hold the argument if provided
ABS_PS_SCRIPT_PATH=""      # Will hold the resolved absolute path for file mode
# --- End Global Variables ---

# --- Helper Functions ---
# ... (show_help, _log_error, _log_error_and_exit, _log_verbose, _log_normal - UNCHANGED)
show_help() {
    cat << EOF
Usage: $APP_NAME [options] [path_to_script.ps1]

Formats a PowerShell script using Invoke-Formatter.
If <path_to_script.ps1> is provided, formats the file in-place.
If --stdin is used, reads from stdin and writes formatted output to stdout.

Options:
  --stdin           Read script from stdin, write formatted script to stdout.
  -v, --verbose     Enable verbose output (ignored in --stdin mode unless errors).
  -s, --silent      Enable silent output (only errors, default for --stdin mode).
  -h, --help        Display this help message and exit.

The settings file (PSScriptFormatterSettings.psd1) for formatting rules is expected at:
  $SETTINGS_FILE_PATH
EOF
}

_log_error() {
    echo "$APP_NAME: Error: $@" >&2
}

_log_error_and_exit() {
    _log_error "$1"
    if [[ "${2:-}" == "show_help" ]]; then
        echo "" >&2
        show_help >&2
    fi
    exit "${3:-1}"
}

_log_verbose() {
    if [[ "$flag_stdin_mode" == false && "$flag_verbose" == true ]]; then
        echo "$@"
    fi
}

_log_normal() {
    if [[ "$flag_stdin_mode" == false && "$flag_silent" == false ]]; then
        echo "$@"
    fi
}
# --- End Helper Functions ---

# --- Argument Parsing ---
# Needs to handle paths that might start with '-' if we didn't have options first
# For now, simple loop is fine.
parsed_args=() # Use a different name to avoid confusion with shell's args
while [[ "$#" -gt 0 ]]; do
    case "$1" in
        --stdin)
            flag_stdin_mode=true
            flag_silent=true # Default to silent for logging in stdin mode
            shift
            ;;
        -v|--verbose)
            flag_verbose=true
            shift
            ;;
        -s|--silent)
            flag_silent=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -*) # Unknown option
            _log_error_and_exit "Unknown option: $1" "show_help"
            ;;
        *) # Accumulate non-option arguments (potential file path)
            # Only one non-option argument (the script path) is expected if not stdin mode
            if [[ "$flag_stdin_mode" == false && -n "$target_ps_script_path_arg" ]]; then
                _log_error_and_exit "Too many script paths provided. Expected one, or use --stdin." "show_help"
            elif [[ "$flag_stdin_mode" == false ]]; then
                target_ps_script_path_arg="$1"
            fi
            # If in stdin mode, non-option args are ignored or could be an error
            # For now, just take the first one if not in stdin mode
            shift
            ;;
    esac
done


# If silent is true, it generally overrides verbose for logging purposes
if [[ "$flag_silent" == true ]]; then
    flag_verbose=false # Verbose logging disabled if silent
fi
# --- End Argument Parsing ---


# --- Pre-execution Checks (common for both modes) ---
if ! command -v pwsh &> /dev/null; then
    _log_error_and_exit "'pwsh' (PowerShell) command not found. Please install PowerShell Core."
fi

if [[ ! -f "$SETTINGS_FILE_PATH" ]]; then
    _log_error_and_exit "PSScriptFormatter settings file not found at '$SETTINGS_FILE_PATH'."
fi
# --- End Pre-execution Checks ---


# ===========================
# STDIN to STDOUT Mode (Helix)
# ===========================
if [[ "$flag_stdin_mode" == true ]]; then
    if [[ -n "$target_ps_script_path_arg" ]]; then
        _log_error "Warning: File path '$target_ps_script_path_arg' provided with --stdin, it will be ignored." >&2
    fi

    script_content_from_stdin=$(cat)
    if [[ -z "$script_content_from_stdin" && ! -t 0 ]]; then # Content is empty and stdin is not a TTY (likely piped empty)
        exit 0 # Exit cleanly if piped empty content
    elif [[ -z "$script_content_from_stdin" && -t 0 ]]; then # No input and stdin is a TTY
        _log_error_and_exit "No script content provided via stdin."
    fi


    CORE_PWSH_LOGIC_STDIN=$(cat <<'EOF'
$ErrorActionPreference = 'Stop'
# $scriptContent and $settingsPath will be passed

if (-not (Get-Module PSScriptAnalyzer -ListAvailable)) {
    try { Install-Module PSScriptAnalyzer -Scope CurrentUser -Force -Confirm:$false -ErrorAction Stop > $null } catch { exit 1 }
}
Import-Module PSScriptAnalyzer -ErrorAction Stop

try {
    $formattedContent = Invoke-Formatter -ScriptDefinition $scriptContent -Settings $settingsPath -ErrorAction Stop
    Write-Output $formattedContent
} catch {
    $errorMessage = "pwshFmt (stdin): PowerShell Formatting Error:`n"
    $errorMessage += "Exception Type: $($_.Exception.GetType().FullName)`n"
    $errorMessage += "Exception Message: $($_.Exception.Message)`n"
    if ($_.ScriptStackTrace) { $errorMessage += "ScriptStackTrace:`n$($_.ScriptStackTrace)`n" }
    Write-Error $errorMessage # To STDERR
    exit 1
}
EOF
    )

    # Note: Using single quotes around "$script_content_from_stdin" when passing to PS.
    # This makes it a literal string in PS, handling most special characters.
    # Complex content with its own single quotes might need more advanced escaping.
    # For typical PS scripts, this should be okay.
    # Alternatively, pass via environment variable or temporary file if extreme cases arise.
    FULL_PWSH_COMMAND_STDIN="& { param([string]\$scriptContent, [string]\$settingsPath); $CORE_PWSH_LOGIC_STDIN } -scriptContent '$(echo "$script_content_from_stdin" | sed "s/'/''/g")' -settingsPath '$SETTINGS_FILE_PATH'"


    if pwsh -NoProfile -Command "$FULL_PWSH_COMMAND_STDIN"; then
        exit 0
    else
        exit 1
    fi
fi # End of stdin_mode


# ===========================
# File In-Place Mode (Original)
# ===========================
# This block now only runs if flag_stdin_mode is false

if [[ -z "$target_ps_script_path_arg" ]]; then
     _log_error_and_exit "No PowerShell script path provided and --stdin not used." "show_help"
fi

# Resolve ABS_PS_SCRIPT_PATH now that we know we are in file mode and have target_ps_script_path_arg
if command -v realpath &> /dev/null; then
    ABS_PS_SCRIPT_PATH="$(realpath "$target_ps_script_path_arg")"
elif command -v readlink &> /dev/null && readlink -f / &> /dev/null; then
    ABS_PS_SCRIPT_PATH="$(readlink -f "$target_ps_script_path_arg")"
else
    if [[ "${target_ps_script_path_arg:0:1}" == "/" ]] || [[ "${target_ps_script_path_arg:0:2}" == "~/" ]]; then
        if [[ "${target_ps_script_path_arg:0:2}" == "~/" ]]; then
            ABS_PS_SCRIPT_PATH="$HOME/${target_ps_script_path_arg:2}"
        else
            ABS_PS_SCRIPT_PATH="$target_ps_script_path_arg"
        fi
    else
        ABS_PS_SCRIPT_PATH="$PWD/$target_ps_script_path_arg"
    fi
fi

if [[ ! -f "$ABS_PS_SCRIPT_PATH" ]]; then
    _log_error_and_exit "PowerShell script not found at '$ABS_PS_SCRIPT_PATH' (resolved from '$target_ps_script_path_arg')."
fi


_log_verbose "Verbose mode enabled (file mode)."
_log_verbose "Attempting to format: '$ABS_PS_SCRIPT_PATH'" # This should now have a value
_log_verbose "Using settings from (path): '$SETTINGS_FILE_PATH'"
_log_verbose "---"

initial_timestamp=""
# ... (rest of the file mode logic, including CORE_PWSH_LOGIC_FILE, timestamp, pwsh execution, reporting - UNCHANGED from previous working version) ...
if [[ "$flag_silent" == false ]]; then
    if command -v stat &> /dev/null; then
        if stat -c %Y "$ABS_PS_SCRIPT_PATH" &> /dev/null; then
            initial_timestamp=$(stat -c %Y "$ABS_PS_SCRIPT_PATH")
        elif stat -f %m "$ABS_PS_SCRIPT_PATH" &> /dev/null; then
            initial_timestamp=$(stat -f %m "$ABS_PS_SCRIPT_PATH")
        fi
        [[ -n "$initial_timestamp" ]] && _log_verbose "Initial file timestamp: $initial_timestamp"
    fi
fi

start_time_ns=$(date +%s%N)

CORE_PWSH_LOGIC_FILE=$(cat <<'EOF'
$ErrorActionPreference = 'Stop'

if ($pwshVerboseFlag) {
    Write-Host "PowerShell side (inside invoked block, verbose mode, file mode):"
    Write-Host "  Script to format: $scriptToFormatPath"
    Write-Host "  Settings file path: $settingsPath"
}

# Test-Path checks already done in bash for $settingsPath in this version
# Test-Path for $scriptToFormatPath is also done by bash.

if (-not (Get-Module PSScriptAnalyzer -ListAvailable)) {
    if ($pwshVerboseFlag) { Write-Warning "PSScriptAnalyzer module not found. Attempting to install for current user..." }
    try {
        Install-Module PSScriptAnalyzer -Scope CurrentUser -Force -Confirm:$false -ErrorAction Stop
        if ($pwshVerboseFlag) { Write-Host "PSScriptAnalyzer installed successfully." -ForegroundColor Green }
    } catch {
        Write-Error "Failed to install PSScriptAnalyzer. Please install it manually and try again."
        exit 1
    }
}
Import-Module PSScriptAnalyzer -ErrorAction Stop

try {
    if ($pwshVerboseFlag) {
        Write-Host "---"
        Write-Host "Formatting script with Invoke-Formatter using PSScriptAnalyzer-style settings file..."
    }
    $originalContent = Get-Content -Path $scriptToFormatPath -Raw -Encoding UTF8
    $formattedContent = Invoke-Formatter -ScriptDefinition $originalContent -Settings $settingsPath -ErrorAction Stop
    if ($formattedContent -ne $originalContent) {
        Set-Content -Path $scriptToFormatPath -Value $formattedContent -Encoding UTF8 -Force
        if ($pwshVerboseFlag) { Write-Host "PowerShell: Script '$scriptToFormatPath' has been formatted." -ForegroundColor Green }
    } else {
        if ($pwshVerboseFlag) { Write-Host "PowerShell: Script '$scriptToFormatPath' is already formatted. No changes made." -ForegroundColor Cyan }
    }
} catch {
    $errorMessage = "PowerShell Error Details (file mode):`n"
    $errorMessage += "Exception Type: $($_.Exception.GetType().FullName)`n"
    $errorMessage += "Exception Message: $($_.Exception.Message)`n"
    if ($_.ScriptStackTrace) { $errorMessage += "ScriptStackTrace:`n$($_.ScriptStackTrace)`n" }
    if ($_.Exception.InnerException) { $errorMessage += "Inner Exception Type: $($_.Exception.InnerException.GetType().FullName)`n"; $errorMessage += "Inner Exception Message: $($_.Exception.InnerException.Message)`n" }
    Write-Output $errorMessage # Captured by bash
    exit 1
}
EOF
)

pwsh_args_file=()
# ABS_PS_SCRIPT_PATH should be correctly populated here now for file mode
pwsh_args_file+=("-scriptToFormatPath" "$ABS_PS_SCRIPT_PATH")
pwsh_args_file+=("-settingsPath" "$SETTINGS_FILE_PATH")

if [[ "$flag_verbose" == true ]]; then
    pwsh_args_file+=("-pwshVerboseFlag" '$true')
else
    pwsh_args_file+=("-pwshVerboseFlag" '$false')
fi
FULL_PWSH_COMMAND_FILE="& { param([string]\$scriptToFormatPath, [string]\$settingsPath, [bool]\$pwshVerboseFlag); $CORE_PWSH_LOGIC_FILE } ${pwsh_args_file[*]}"


pwsh_output_capture_file=$(mktemp)
trap 'rm -f "$pwsh_output_capture_file"' EXIT # Ensure cleanup

execution_succeeded=false
if pwsh -NoProfile -Command "$FULL_PWSH_COMMAND_FILE" > "$pwsh_output_capture_file" 2>&1; then
    execution_succeeded=true
else
    execution_succeeded=false
fi

end_time_ns=$(date +%s%N)
duration_ns=$((end_time_ns - start_time_ns))

final_timestamp=""
file_was_modified=false
if [[ "$flag_silent" == false || "$execution_succeeded" == false ]]; then
    if command -v stat &> /dev/null; then
        if stat -c %Y "$ABS_PS_SCRIPT_PATH" &> /dev/null; then final_timestamp=$(stat -c %Y "$ABS_PS_SCRIPT_PATH"); fi
        if [[ -z "$final_timestamp" ]] && stat -f %m "$ABS_PS_SCRIPT_PATH" &> /dev/null; then final_timestamp=$(stat -f %m "$ABS_PS_SCRIPT_PATH"); fi
    fi
    if [[ -n "$initial_timestamp" && -n "$final_timestamp" && "$initial_timestamp" != "$final_timestamp" ]]; then
        file_was_modified=true
    fi
fi

if [[ "$execution_succeeded" == true ]]; then
    if [[ "$file_was_modified" == true ]]; then
        _log_normal "Formatted: '$ABS_PS_SCRIPT_PATH'"
    else
        _log_normal "No changes: '$ABS_PS_SCRIPT_PATH' (already compliant)"
    fi
    _log_verbose "$(cat "$pwsh_output_capture_file")"
else
    _log_error "Formatting failed for '$ABS_PS_SCRIPT_PATH'."
    cat "$pwsh_output_capture_file" >&2 # Show PS errors
fi

if [[ "$flag_silent" == false || "$execution_succeeded" == false ]]; then
    duration_s=$(awk -v ns="$duration_ns" 'BEGIN{printf "%.3f", ns/1000000000}')
    if [[ "$flag_silent" == false ]]; then
        _log_normal "Execution time: ${duration_s}s"
    elif [[ "$execution_succeeded" == false && "$flag_silent" == true ]]; then
        echo "Execution time: ${duration_s}s" >&2
    fi
    _log_verbose "Detailed execution time: ${duration_ns}ns ($(awk -v ns="$duration_ns" 'BEGIN{printf "%d", ns/1000000}')ms)"
fi

if [[ "$execution_succeeded" == true ]]; then
    exit 0
else
    exit 1
fi
